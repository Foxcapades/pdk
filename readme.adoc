= Primitive Deque Types
:srcDir: src/main/kotlin/io/foxcapades/lib/pdk
:source-highlighter: highlightjs

image:https://img.shields.io/github/license/Foxcapades/pdk[]
image:https://img.shields.io/badge/jdk-1.8-blue[]
image:https://img.shields.io/badge/docs-dokka-darkgreen[link="https://foxcapades.github.io/pdk/"]
image:https://img.shields.io/maven-central/v/io.foxcapades.lib/pdk[Maven Central, link="https://search.maven.org/search?q=g:io.foxcapades.lib%20AND%20a:pdk"]

Simple library that provides Deque implementations for all Kotlin's primitive
types that deal in unboxed values.

== Usage

.`*build.gradle.kts*`
[source, kotlin]
----
dependencies {
  implementation("io.foxcapades.lib:pdk:1.0.1")
}
----

=== Method & Property Aliases

Similar to the JDK's `Queue` type and various implementations, the `*Deque`
types have multiple aliases for most properties and methods that align with
different use cases or implementations from different languages.  Each alias is
an inline method or property allowing library users to choose the specific
syntax they prefer without any call-stack overhead.  This is particularly useful
when porting libraries or code from other languages such as C++ into Kotlin.

The head and tail of the deque are named just that, "head", and "tail", however
they are also accessible via "front", "first", "back", and "last" for most
properties and methods, for example, the property `head`, which is handle on the
first element in the deque, has the alias properties `first` and `front`,
similarly the method `pushHead`, which pushes an element onto the head of the
deque, has the alias methods `pushFirst` and `pushFront`.

=== Footprint

`pdk` aims to be as lightweight as possible both in terms of memory and compute
footprint.  All of the `PrimitiveDeque` implementations wrap 3 properties, a
primitive array of a specified capacity, an `int` value recording the current
size of the deque, and one more `int` value tracking the internal 'head'
position in the deque's backing array.

Additionally, in all situations where it is possible, copy operations are
performed by the JDK's `System.arrayCopy` method.

Presently the only situation where `System.arrayCopy` is not used on copy is
when copying the contents of a JDK `Collection` into a deque.

== Provided Types

* link:{srcDir}/BooleanDeque.kt[`BooleanDeque`]
* link:{srcDir}/CharDeque.kt[`CharDeque`]
* link:{srcDir}/ByteDeque.kt[`ByteDeque`]
* link:{srcDir}/ShortDeque.kt[`ShortDeque`]
* link:{srcDir}/IntDeque.kt[`IntDeque`]
* link:{srcDir}/LongDeque.kt[`LongDeque`]
* link:{srcDir}/FloatDeque.kt[`FloatDeque`]
* link:{srcDir}/DoubleDeque.kt[`DoubleDeque`]
* link:{srcDir}/UByteDeque.kt[`UByteDeque`]
* link:{srcDir}/UShortDeque.kt[`UShortDeque`]
* link:{srcDir}/UIntDeque.kt[`UIntDeque`]
* link:{srcDir}/ULongDeque.kt[`ULongDeque`]

== Development

As all the types in this library are identical apart for the primitive type they
deal in, the code for most files is generated based on the contents of the
link:{srcDir}/ByteDeque.kt[`ByteDeque`] file.

To modify this library, the only source files that should be manually edited are
the base type, link:{srcDir}/PrimitiveDeque.kt[`PrimitiveDeque`], and the
implementation type, link:{srcDir}/ByteDeque.kt[`ByteDeque`].

After the adjustments are made to those two files, the remaining files can be
generated by calling `make clone-deques`.

=== The Base Type

This contains a singular, abstract base class,
link:{srcDir}/PrimitiveDeque.kt[`PrimitiveDeque`], that defines what shared
functionality can be defined without dealing in generics, and thus, primitive
boxing.  This type _does_ take generic parameters, however those are used
exclusively to define the JDK interop functions that, sadly, must deal in boxed
values.  An example of one such method is `iterator()` defined by the generic
type `Iterable<V>`.